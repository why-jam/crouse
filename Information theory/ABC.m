%计算信道容量
clear;clc;
Q = [1/3 1/3 1/6 1/6;
     1/6 1/6 1/3 1/3];
%{
Q = [0.5 0.5 0 0;
     0 0.5 0.5 0;
     0 0 0.5 0.5;
     0.5 0 0 0.5];
%理论分布 0.25 0.25 0.25 0.25
%理论C = 1 bit
%}
%{
Q = [1/3 1/3 1/6 1/6;
     1/6 1/6 1/3 1/3];
%理论分布 0.25 0.25
%理论C = log2(4)+1/3*(log2(1/3)*2+log2(1/6))=0.0817 bit
%}
%{
Q = [1 0;
     0.5 0.5];
%理论分布 0.6 0.4
%理论C = 0.3219 bit
%}

[m,n]=size(Q);
x=rand(1,m);
r_x=x/sum(x);
%r_x = ones(1,m)/m; % 初始化输入分布
e=1e-6;%停止迭代的容差限
CN=1;C=0;N=0;

while (abs(CN-C))>e&&N<1000
    Q_ = r_x.*Q'./repmat((r_x*Q)',[1 m]); %后验概率矩阵
    Q_(Q_==0)=1; %为了计算对数时将0对数成0
    fz = exp(diag(Q*log(Q_))); %分子
    fm = sum(fz); %分母
    r_x = fz'/fm;
    
    %计算信道容量
    C = CN;
    Q_y = Q./repmat(r_x*Q,[m 1]);
    Q_y(Q_y==0)=1;
    CN = r_x*sum(Q.*log2(Q_y),2);
    N=N+1;
end
disp(['信道容量为：',num2str(C),' bit']);
disp(['输入分布为：',num2str(r_x)]);
disp(['迭代次数为：',num2str(N)]);